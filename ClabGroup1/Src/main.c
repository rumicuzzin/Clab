/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f303xc.h"

#include "serial.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#define ALTFUNCTION 0xA00
#define RXTX 0x770000
#define HIGHSPEED 0xF00
#define BAUDRATE 0x46
#define BUFFER 10
#define LED_OUTPUT 0x5555

//void enableUSART1();
void enableLEDs();

void finished_transmission(uint32_t bytes_sent) {
	// This function will be called after a transmission is complete

	volatile uint32_t test = 0;
	// make a very simple delay
	for (volatile uint32_t i = 0; i < 0x8ffff; i++) {
		// waste time !
	}
}

int main(void)
{
// Code from git, for receiving
	uint8_t *string_to_send = "Sally is a beautiful dog!\r\n";

	//void (*completion_function)(uint32_t) = &finished_transmission;

	SerialInitialise(BAUD_115200, &USART1_PORT, &finished_transmission);

//	enableUSART1();
	enableLEDs();

	// Buffer to store incoming characters
	unsigned char string[BUFFER];
	int i = 0;

/* Loop forever */
	for(;;)
	{

		SerialOutputString(string_to_send, &USART1_PORT);

		// Check for overrun or frame errors
		if ((USART1->ISR & USART_ISR_FE_Msk) || (USART1->ISR & USART_ISR_ORE_Msk))
		{
			continue;
		}

		// If we have stored the maximum amount, stop
		if (i == BUFFER)
		{
		    // Wipe the buffer by setting all its elements to 0, there is something wrong here, after 10 characters received it breaks
			for (int n = 0; n < BUFFER; n++)
			{
				string[n] = 0;
			}

		}

		// Data received
		if (USART1->ISR & USART_ISR_RXNE_Msk)
		{
			// Read data
			unsigned char data = (uint8_t) USART1->RDR;

			// Store the read data
			string[i] = data;

			if (string[i] == '#') {
				continue;
			}
			i++;

			// add if statement here for if the char is the terminating character

			// Toggle LEDs
			uint8_t* lights = ((uint8_t*)&(GPIOE->ODR)) + 1;
			*lights = !(*lights);
//			*lights ^= 0xAA;

		}
	}
}

void enableUSART1()
{
	// Enable GPIO C and USART1's clocks
	RCC->AHBENR |= RCC_AHBENR_GPIOCEN_Msk;
	RCC->APB2ENR |= RCC_APB2ENR_USART1EN_Msk;

	// Set GPIO C to use UART as alternate function
	GPIOC->MODER = ALTFUNCTION;
	GPIOC->AFR[0] = RXTX;
	GPIOC->OSPEEDR = HIGHSPEED;

	// Set the baud rate and ready USART 1 for both receive and transmit
	USART1->BRR = BAUDRATE;                   // Baud rate = 115200
	USART1->CR1 |= USART_CR1_RE_Msk;
	USART1->CR1 |= USART_CR1_TE_Msk;
	USART1->CR1 |= USART_CR1_UE_Msk;
}

void enableLEDs()
{
	// Enable clock for Port E (LEDs)
	RCC->AHBENR |= RCC_AHBENR_GPIOEEN;

	// Get the most significant 16 bits of port mode register as that is where the mode for the LEDs are defined
	uint16_t* portMode = ((uint16_t*)&(GPIOE->MODER))+1;

	// Set the mode of the port pins to output since they are LEDs
	*portMode = LED_OUTPUT;
}





