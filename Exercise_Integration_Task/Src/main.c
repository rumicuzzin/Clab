/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include "../Inc/common.h"

// #if !defined(__SOFT_FP__) && defined(__ARM_FP)
//   #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
// #endif

 #define ALTFUNCTION 0xA00
 #define RXTX 0x770000
 #define HIGHSPEED 0xF00
 #define BAUDRATE 0x46
 #define LED_OUTPUT 0x5555

 void enableLEDs();
 void processBuffer(unsigned char* buffer, int size);
 void parseCommand(unsigned char *inputBuffer);



 int main(void)
 {
     uint8_t *string_to_send = (uint8_t*)"Sally is a beautiful dog!\r\n";
     SerialInitialise(BAUD_115200, &USART1_PORT, '$',&processBuffer);
     USART1RX_enableInterrupts();
     enableLEDs();

     // Loop forever
     for(;;)
     {
    	 // Transmit string_to_send via USART1
    	 // SerialOutputString(string_to_send, &USART1_PORT);
     }
 }


 // Function to process buffer contents - always processes the inactive buffer
 void processBuffer(unsigned char* buffer, int size) {
	 buffer[size] = '\0';
	uint8_t* lights = ((uint8_t*)&(GPIOE->ODR)) + 1;
	*lights = !(*lights);

	// For demonstration purposes, send a message indicating buffer processing
	SerialOutputString((uint8_t*)"Processing inactive buffer...",&USART1_PORT);
	// Now call parseCommand
	parseCommand(buffer);
 }

 /**
  * Splits the input buffer into:
  *   command -> the first word
  *   operand -> the rest of the string
  * Then performs the action based on the command.
  */
 void parseCommand(unsigned char *inputBuffer)
 {
     // The buffer is presumably zero-terminated or we can forcibly zero-terminate.
     // If not, do something like:
     //inputBuffer[size] = '\0';

	// Everyime there is a new command we will disable any active timers
	TIM2->DIER &= ~TIM_DIER_UIE;     // Disable update interrupt
	NVIC_DisableIRQ(TIM2_IRQn);      // Disable NVIC interrupt
	TIM2->CR1 &= ~TIM_CR1_CEN;       // Stop the timer

     // Find the first space
     char *spacePtr = strchr((char*)inputBuffer, ' ');

     // If there is no space, we treat the whole buffer as the command and there's no operand
     if (spacePtr == 0)
     {
         // Handle cases where incorrect command is entered
         if (strcmp((char*)inputBuffer, "serial") == 0) {
             SerialOutputString((uint8_t*)"No operand given. Please send in the form 'serial [message to send]'\r\n", &USART1_PORT);
         }
         else if (strcmp((char*)inputBuffer, "led") == 0) {
             SerialOutputString((uint8_t*)"No operand given. Please send in the form 'led [bitmask]'\r\n", &USART1_PORT);
         }
         else if (strcmp((char*)inputBuffer, "oneshot") == 0) {
             SerialOutputString((uint8_t*)"No operand given. Please send in the form 'oneshot [number of milliseconds]'\r\n", &USART1_PORT);
         }
         else if (strcmp((char*)inputBuffer, "timer") == 0) {
             SerialOutputString((uint8_t*)"No operand given. Please send in the form 'timer [number of milliseconds]'\r\n", &USART1_PORT);
         }
         else {
             // Unknown operator sent
             SerialOutputString((uint8_t*)"The input you entered is invalid. Please send 'led', 'serial','oneshot', or 'timer'.\r\n", &USART1_PORT);
         }
         return;
     }

     // Zero-terminate at the space, turning the input into two separate strings
     *spacePtr = '\0';  // Now inputBuffer is "command", spacePtr+1 is the operand

     // The command is the start of inputBuffer
     char *command = (char*)inputBuffer;

     if (*command == '\n'){
    	 command +=1;
     }
     // The operand is right after the space
     char *operand = spacePtr + 1;  // might be an empty string if input ended with a space
     // Variable to store binary of operand variable
     uint32_t binary_value = 0;
     uint32_t value = 0;
     //SerialOutputString(command, &USART1_PORT);
     // Compare the command and act
     if (strcmp(command, "serial") == 0)
     {
         // If the command is "serial", then send the operand string
         //   back out over USART
         SerialOutputString((uint8_t*)operand, &USART1_PORT);
         SerialOutputString((uint8_t*)"\r\n", &USART1_PORT);
     }

     else if (strcmp(command, "led") == 0)
     {
         // parse the operand to decide which LED or pattern to set
    	 while (*operand == '0' || *operand == '1') {
    	     // Shift the current value left by 1 bit
    	     binary_value <<= 1;

    	     // Add the current bit (0 or 1)
    	     if (*operand == '1') {
    	         binary_value |= 1;
    	     }

    	     // Move to the next character
    	     operand++;
    	 }
    	 update_leds(binary_value);
     }

     else if (strcmp(command, "oneshot") == 0)
     {
    	 // Convert chat to value
    	 value = (uint32_t)strtoul(operand, NULL, 10);

    	 // Alll led's will light up after the specified delay time in ms
    	 enable_clocks();
    	 one_shot_trigger(value, &flash_led);
         // parse the operand to decide oneshot milliseconds
     }
     else if (strcmp(command, "timer") == 0)
     {
    	enable_clocks();
    	value = (uint32_t)strtoul(operand, NULL, 10);
		set_x(value);
		repeating_timer_init(value, &set_led);

         // parse the operand to decide timer milliseconds
     }
     else
     {
         // Unknown command
         SerialOutputString((uint8_t*)"The operator you entered is invalid. Please send 'led', 'serial','oneshot', or 'timer'.\r\n", &USART1_PORT);
     }
 }

 void enableLEDs()
 {
     // Enable clock for Port E (LEDs)
     RCC->AHBENR |= RCC_AHBENR_GPIOEEN;

     // Get the most significant 16 bits of port mode register as that is where the mode for the LEDs are defined
     uint16_t* portMode = ((uint16_t*)&(GPIOE->MODER))+1;

     // Set the mode of the port pins to output since they are LEDs
     *portMode = LED_OUTPUT;
 }
