/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

 #include <int_serial.h>
#include <stdint.h>
 #include "stm32f303xc.h"

 #if !defined(__SOFT_FP__) && defined(__ARM_FP)
   #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
 #endif

 #define ALTFUNCTION 0xA00
 #define RXTX 0x770000
 #define HIGHSPEED 0xF00
 #define BAUDRATE 0x46
 #define LED_OUTPUT 0x5555

 void enableLEDs();
 void processBuffer(unsigned char* buffer, int size);
 void parseCommand(unsigned char *inputBuffer);

 int main(void)
 {
     uint8_t *string_to_send = "Sally is a beautiful dog!\r\n";
     SerialInitialise(BAUD_115200, &USART1_PORT, '$',&processBuffer);
     USART1RX_enableInterrupts();
     enableLEDs();

     // Loop forever
     for(;;)
     {
    	 // Transmit string_to_send via USART1
    	 // SerialOutputString(string_to_send, &USART1_PORT);
     }
 }

 // Function to process buffer contents - always processes the inactive buffer
 void processBuffer(unsigned char* buffer, int size) {
	 buffer[size] = '\0';
	uint8_t* lights = ((uint8_t*)&(GPIOE->ODR)) + 1;
	*lights = !(*lights);

	// For demonstration purposes, send a message indicating buffer processing
	SerialOutputString("Processing inactive buffer...",&USART1_PORT);
	// Now call parseCommand
	parseCommand(buffer);
 }

 /**
  * Splits the input buffer into:
  *   command -> the first word
  *   operand -> the rest of the string
  * Then performs the action based on the command.
  */
 void parseCommand(unsigned char *inputBuffer)
 {
     // The buffer is presumably zero-terminated or we can forcibly zero-terminate.
     // If not, do something like:
     // inputBuffer[size] = '\0';

     // Find the first space
     char *spacePtr = strchr((char*)inputBuffer, ' ');

     // If there is no space, we treat the whole buffer as the command and there's no operand
     if (spacePtr == 0)
     {
         // Handle cases where incorrect command is entered
         if (strcmp((char*)inputBuffer, "serial") == 0) {
             SerialOutputString((uint8_t*)"No operand given. Please send in the form 'serial [message to send]'\r\n", &USART1_PORT);
         }
         else if (strcmp((char*)inputBuffer, "led") == 0) {
             SerialOutputString((uint8_t*)"No operand given. Please send in the form 'led [bitmask]'\r\n", &USART1_PORT);
         }
         else if (strcmp((char*)inputBuffer, "oneshot") == 0) {
             SerialOutputString((uint8_t*)"No operand given. Please send in the form 'oneshot [number of milliseconds]'\r\n", &USART1_PORT);
         }
         else if (strcmp((char*)inputBuffer, "timer") == 0) {
             SerialOutputString((uint8_t*)"No operand given. Please send in the form 'timer [number of milliseconds]'\r\n", &USART1_PORT);
         }
         else {
             // Unknown operator sent
             SerialOutputString((uint8_t*)"The input you entered is invalid. Please send 'led', 'serial','oneshot', or 'timer'.\r\n", &USART1_PORT);
         }
         return;
     }

     // Zero-terminate at the space, turning the input into two separate strings
     *spacePtr = '\0';  // Now inputBuffer is "command", spacePtr+1 is the operand

     // The command is the start of inputBuffer
     char *command = (char*)inputBuffer;

     // The operand is right after the space
     char *operand = spacePtr + 1;  // might be an empty string if input ended with a space

     // Compare the command and act
     if (strcmp(command, "serial") == 0)
     {
         // If the command is "serial", then send the operand string
         //   back out over USART
         SerialOutputString((uint8_t*)operand, &USART1_PORT);
         SerialOutputString((uint8_t*)"\r\n", &USART1_PORT);
     }
     else if (strcmp(command, "led") == 0)
     {
    	 SerialOutputString((uint8_t*)"LED if statement working.\r\n", &USART1_PORT);
     }
     else if (strcmp(command, "oneshot") == 0)
     {
         // parse the operand to decide oneshot milliseconds
     }
     else if (strcmp(command, "timer") == 0)
     {
         // parse the operand to decide timer milliseconds
     }
     else
     {
         // Unknown command
         SerialOutputString((uint8_t*)"The operator you entered is invalid. Please send 'led', 'serial','oneshot', or 'timer'.\r\n", &USART1_PORT);
     }
 }

 void enableLEDs()
 {
     // Enable clock for Port E (LEDs)
     RCC->AHBENR |= RCC_AHBENR_GPIOEEN;

     // Get the most significant 16 bits of port mode register as that is where the mode for the LEDs are defined
     uint16_t* portMode = ((uint16_t*)&(GPIOE->MODER))+1;

     // Set the mode of the port pins to output since they are LEDs
     *portMode = LED_OUTPUT;
 }
